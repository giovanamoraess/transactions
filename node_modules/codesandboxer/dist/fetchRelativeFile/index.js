'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _parseFile = require('../parseFile');

var _parseFile2 = _interopRequireDefault(_parseFile);

var _replaceImports = require('../replaceImports');

var _replaceImports2 = _interopRequireDefault(_replaceImports);

var _absolutesToRelative = require('../utils/absolutesToRelative');

var _absolutesToRelative2 = _interopRequireDefault(_absolutesToRelative);

var _getUrl2 = require('./getUrl');

var _getUrl3 = _interopRequireDefault(_getUrl2);

require('isomorphic-unfetch');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
This is modified from the canvas answer here:
https://stackoverflow.com/questions/6150289/how-to-convert-image-into-base64-string-using-javascript
*/
function fetchImage(url, path) {
  return new _promise2.default(function (resolve) {
    var img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = url;

    img.onload = function () {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      var dataURL;
      canvas.height = this.naturalHeight;
      canvas.width = this.naturalWidth;
      ctx.drawImage(this, 0, 0);
      dataURL = canvas.toDataURL();
      resolve(dataURL);
    };
  }).then(function (file) {
    return { file: file, deps: {}, internalImports: [], path: path };
  });
}


var fetchJS = function fetchJS(url, path, pkg, importReplacements) {
  return fetch(url).then(function (res) {
    if (res.status === 404) {
      throw new Error('file not found at: ' + url);
    }
    return res.text();
  }).then(function (content) {
    return (0, _replaceImports2.default)(content, importReplacements.map(function (m) {
      return [(0, _absolutesToRelative2.default)(path, m[0]), m[1]];
    }));
  })
  // this is not correct
  .then(function (content) {
    return (0, _parseFile2.default)(content, pkg);
  }).then(function (file) {
    return (0, _extends3.default)({}, file, { path: path });
  });
};

var fetchRaw = function fetchRaw(url, path) {
  return fetch(url).then(function (res) {
    if (res.status === 404) {
      throw new Error('file not found at: ' + url);
    }
    return res.text();
  }).then(function (file) {
    return { file: file, deps: {}, internalImports: [], path: path };
  });
};

/*
resolution order:
A.js
A.json
A.jsx (if allowed)
A/index.js
A/index.json
A/index.jsx (if allowed)
*/

var catchBlock = function catchBlock(e, url, path, pkg, importReplacements, extension) {
  if (e.message.includes('file not found at:')) {
    var newPath = '' + path + extension;
    var newUrl = url.replace(/.js$/, extension);
    if (extension === '.json') {
      return fetchRaw(newUrl, newPath);
    }
    return fetchJS(newUrl, newPath, pkg, importReplacements);
  } else {
    throw e;
  }
};

// Imports that are not named may be .js, .json, or /index.js. Node resolves them
// in that order.
var fetchProbablyJS = function fetchProbablyJS(url, path, pkg, importReplacements, config) {
  // This first fetch handles .js
  return fetchJS(url, path, pkg, importReplacements).catch(function (e) {
    return catchBlock(e, url, path, pkg, importReplacements, '.json');
  }).catch(function (e) {
    if (config.allowJSX) {
      return catchBlock(e, url, path, pkg, importReplacements, '.jsx');
    } else throw e;
  }).catch(function (e) {
    return catchBlock(e, url, path, pkg, importReplacements, '/index.js');
  }).catch(function (e) {
    return catchBlock(e, url, path, pkg, importReplacements, '/index.json');
  }).catch(function (e) {
    if (config.allowJSX) {
      return catchBlock(e, url, path, pkg, importReplacements, '/index.jsx');
    } else throw e;
  });
};

var fetchFileContents = function fetchFileContents(url, path, _ref, config) {
  var fileType = _ref.fileType,
      pkg = _ref.pkg,
      importReplacements = _ref.importReplacements;

  switch (fileType) {
    case '.png':
    case '.jpeg':
    case '.jpg':
    case '.gif':
    case '.bmp':
    case '.tiff':
      return fetchImage(url, path);
    case '.js':
      return fetchProbablyJS(url, path, pkg, importReplacements, config);
    case '.jsx':
      return fetchJS(url, path, pkg, importReplacements);
    case '.json':
    case '.css':
      return fetchRaw(url, path);
    default:
      throw new Error('unparseable filetype: ' + fileType + ' for file ' + path);
  }
};

exports.default = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(path, pkg, importReplacements, gitInfo, config) {
    var _getUrl, url, fileType, file;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            config = config || {};
            // The new path is the file name we will provide to codesandbox
            // Get the url from the gitInfo. For JS files, we will need to add the filetype
            // This method needs to determine the filetype, so we return it.
            _getUrl = (0, _getUrl3.default)(path, gitInfo), url = _getUrl.url, fileType = _getUrl.fileType;
            _context.next = 4;
            return fetchFileContents(url, path, {
              fileType: fileType,
              pkg: pkg,
              importReplacements: importReplacements
            }, config);

          case 4:
            file = _context.sent;
            return _context.abrupt('return', file);

          case 6:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  function fetchRelativeFile(_x, _x2, _x3, _x4, _x5) {
    return _ref2.apply(this, arguments);
  }

  return fetchRelativeFile;
}();